The presented technique was prototyped as a tool: PWA-Rel.  We
compared it against S3CAM~\cite{zutshi2014multiple} on several
academic benchmarks. Below, we present the details of the
implementation and the benchmarks used.

\subsection{Implementation}
PWA-Rel was implemented in Python. Its different parts comprised of
the (a) abstraction graph generation, (b) regression analysis and (c)
BMC. S3CAM was used to compute (a). To compute (b), OLS regression
routines were used from Scikit-learn~\cite{pedregosa2011scikit}, a
Python module for machine learning. Finally, the The bounded model
checking (c) was done using the SAL model checker~\cite{SAL-SRI},
which used Yices2~\cite{dutertre2014yices} as the SMT solver. A naive
alternative linear programming (LP) based model checker, specific to
the PWA relational abstractions was implemented utilizing PyGLPK.
Specifically, each path of the graph $G^R$ was sent to the lp solver
PyGLPK and checked for feasibility. If feasible, the checker returned
a concrete counter-example.

PWA-Rel uses S3CAM to discover the abstraction graph $G$, which is
then filtered to remove the nodes from which error nodes are not
reachable. In all our experiments we used $1$-relational modeling to
create the transition system from $G$. This was determined to be a
good trade-off between longer simulations and increase in precision,
with respect to the mentioned benchmarks.

Using the BMC, we checked for the given safety property. If a concrete
trace was obtained, it was further checked for reproducibility by
sampling and simulating its `neighborhood' with the $\simulate$
function. We define `neighborhood' as the abstract states
corresponding to the returned concrete trace.  Specifically, $100$
samples were uniformly randomly chosen and simulated and tested for
error traces. This procedure can also be extended to obtaining
different discrete sequences or discrete trace sequences from the
model checker by requesting distinct counter-examples.

% abstract state was sampled to check the presence of a counter-example
% in it neighborhood. This can be further extended by obtaining
% different discrete sequences or discrete trace sequences from the
% model checker.

\subsection{Evaluation}
We tabulate our preliminary evaluation in \tabref{res-rel}. We used
the more difficult benchmarks described in \cite{zutshi2014multiple},
including the Van der Pol oscillator, Brusselator, Lorenz attractor
and the Navigation benchmark. PWA-Rel and S3CAM were tested $10$ times
with different seeds and their running times were averaged. We tabulate
both the total time taken by PWA-Rel+SAL and PWA-Rel+LP to compute the
counter-example and compare against an implementation of S3CAM.
Different abstraction parameters are used for S3CAM and PWA-Rel, due
to the differences in which they operate. PWA-Rel requires a finer
abstraction to begin with in order to minimize the modeling errors.
On the other hand, a coarser abstraction as the initial abstraction is
works better for S3CAM due to the expensive refinement procedure
involved.

\begin{table}[!htbp]
\centering
\caption{Avg. timings for benchmarks. The \textbf{BMC} column lists
time taken by the BMC engine. The total time in seconds (rounded off
to an integer) is noted under \textbf{PWA-Rel} and \textbf{S3CAM}.
$TO$ signifies time $>5hr$, after which the search was killed.}
\label{tab:res-rel}
\begin{tabular}{@{}llll@{}}
\toprule
    Benchmark & PWA Rel + SAL & PWA Rel + LP & S3CAM\\
\midrule
    Van der Pol ($\prop_3$)   &$0.2$ & $0.34$ & $0.4$\\
    Brusselator               &$0.06$ & $0.06$ & $0.03$\\
    Lorenz                    &$0.4$ & $0.33$ & $0.58$\\
%B.Ball                    &  &   & \\
    Nav ($\prop_P$)           &$TO$ & $28.5$  & $10$ \\%9423 + 4480
    Nav ($\prop_Q$)           &$TO$ & $26$   & $9.1$ \\%8105 + 970
    Nav ($\prop_R$)           &$TO$ & $39.2$  & $33.3$\\
    Nav ($\prop_S$)           &$TO$ & $71$  & $35$\\
    Bouncing Ball             &$Safe$ & $Safe$  & $7.5$\\

\bottomrule
\end{tabular}
\end{table}

% 1m8s, 2m56.184s, 1m31.059s[f], 1m32.665s,  1m45.312s, 1m22.397s, 2m1.451s[f], 1m12.118s, 1m26.596s
% 0.12, 0.06,         0.33       0.13,       0.22,     FAIL,       ,X           0.08        0.15

As apparent form the results, the performance is comparable in all
benchmarks, but the last one: bouncing ball. PWA-Rel determines it to
be `safe' as it can not find a counter-example in the PWA relational
model. Also, apparent from the results, PWA-Rel is more scalable with
the LP solver and PWA-Rel+SAL times out on most of the benchmarks.
The efficiency of the naive LP solver can be attributed to the careful
selection of the parameters for S3CAM (finer abstraction), resulting in
a small subgraph which can be easily explored for all paths.

However, we need to explore more benchmarks to be conclusive on the
tool's performance on real world examples. Although, PWA-Rel does not
need to refine like S3CAM, and should be more scalable, it is still
constrained by the accuracy of the pwa models. Its performance can be
explained by the difficulty in finding an abstraction
($\quant_\epsilon$), which is fine enough, to result in accurate
prediction models but coarse enough to be manageable by the current
bmc tools.  To obtain a reproducible counter-example from the model
checker (and avoid false positives), the transition system should be
created from models with high accuracy, for which a finer abstraction
is required.  However, the exploration of a finer abstraction is
exponentially more complex and results in a much bigger transition
system, which the current state of the art bounded model checkers
(which use generic SMT solvers) can not handle under reasonable
resources.

% more scalable 
\subsection{Search Parameters}

The search parameters for PWA-Rel include the parameters of S3CAM:
$N$, $\epsilon$ and $\Delta$. Additionally, they also include the
maximum error budget $\delta_{max}$ for OLS and the maximum length of
segmented trajectory for building $k$-relational models.

The effects of $N$, $\epsilon$ and $\Delta$
on S3CAM's performance were detailed in~\cite{zutshi2014multiple}. However, they also have an effect on
relational modeling. A finer grid with small cells produces more
accurate models than a coarser grid with large cells. Similarly,
small time length trajectory segments result in more accurate
modeling.
%An increase in the number of samples can increases the
%accuracy of regression.

\paragraph{Maximum Model Error ($\boldsymbol{\delta}_{\bold{max}}$) .}
Given a $\delta_{max}$, we keep increasing $k$ during the
$k$-relational modeling process till $\delta_i \le \delta_{max}$ is
satisfied. A $k_{max}$ is introduced to bound the longest
segmented trajectory which can be considered.

% \paragraph{Bounded k relations ($\boldsymbol{k}_{\bold{max}}$.) }

\subsection{Reasons for Failure}
The approach can fail to find a counter-example, even when it exists, in
one of three ways.

\begin{itemize}

    \item \emph{S3CAM Fails}: No abstract counter-example is found by
        S3CAM. We can remedy it by increasing search budgets and/or
        restarting.

    \item \emph{BMC Fails}: An abstract counter-example is found, but
        the BMC fails to find a concrete counter-example in the PWA
        relational model. The failure can be attributed to either (a)
        a spurious abstract counter-examples or (b) a poorly estimated
        model. The former can be addressed by restarting but the
        latter requires that the maximum model error $\delta_{max}$ be
        decreased.

    \item \emph{Inaccurate PWA Modeling}: An abstract counter-example
        is found, and it is successfully concretized in the PWA
        relational model by the BMC. However, it is not reproducible
        in the black box system. This happens when the PWA relational
        model is not precise enough.
\end{itemize}
